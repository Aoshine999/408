## 一、进程与线程
### 1、进程的概念与特征
#### （1）进程的定义
- 进程是程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能的程序在一个数据集合上运行的过程
- 进程是进程实体的运行过程，是系统进行**资源分配和调度的一个独立单位**
- **为什么引入进程**：
	- 为了使多道程序并发执行，提高资源利用率和系统吞吐量
	- 为了可以对并发执行的程序加以描述和控制，实现操作系统的并发性和共享性

#### （2）进程的特征
- **动态性**：进程是程序的一次执行过程，是动态地产生、变化和消亡的【最基本的特征】
- **并发性**：内存中有多个进程实体，各进程可并发执行
- **独立性**：进程是能独立运行、获得资源、独立接受调度的基本单位
- **异步性**：各进程按各自独立的、不可预知的速度向前推进【操作系统要提供“进程同步机制”来解决异步问题】

#### （3）进程与程序的区别
- 进程：是**动态的**，是程序的一次执行过程【如：可同时启动多次 QQ】
- 程序：是**静态的**，就是存放在磁盘里的可执行文件【如：QQ.exe】
- 同一个程序多次执行会对应多个进程

#### （4）进程的组成
- 一个**进程实体**（进程映像）由 **PCB、程序段、数据段**组成
- 进程是动态的，进程实体是**静态的**
- 进程实体反映了进程在某一时刻的状态
##### 1）进程控制块（PCB）
- **定义**：
	- PCB 是进程实体的一部分，是进程存在的唯一标志
	- 进程创建时，操作系统为它新建一个 PCB，该结构常驻内存
- **包含**：
	1. **进程描述信息**：
		- 进程标识符 PID：标识各个进程，每个进程都有一个并且唯一的标识号
		- 用户标识符 UID：进程归属的用户，用户标识符主要为共享和保护服务
	2. **进程控制和管理信息**：
		- 进程当前状态：描述进程状态信息，作为 CPU 调度的依据
		- 进程优先级：描述进程抢占 CPU 的优先级
		- 代码运行入口地址
		- 程序的外存地址
		- 进入内存时间
		- CPU 占用时间
		- 信号量使用
	3. **资源分配清单**：
		- 有关内存地址空间和虚拟地址空间的状况
		- 所打开文件的列表和所使用的输入/输出设备信息
	4. **处理机相关信息**【CPU 的上下文】：
		- CPU 中各寄存器的值
		- 当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中以便进程重新执行时，能从断点处继续执行
- **组织方式**：
	- 链接方式：
		- 把同一状态的 PCB 链成一个队列，不同状态对应不同的队列
		- 也可把处于阻塞态的进程的 PCB，根据阻塞原因，排成多个阻塞队列
	- 索引方式：
		- 将同一状态的进程组织在一个索引表中，索引表的表项指向相应的 PCB
		- 如就绪索引表，阻塞索引表

##### 2）程序段
- 能被进程调度程序调度到 CPU 执行的程序代码段
- 程序可以被多个进程共享，即多个进程可以运行同一个程序

##### 3）数据段
- 可以是进程对应的程序加工处理的原始数据
- 可以是程序执行时产生的中间或最终结果

### 2、进程的状态与转换
#### （1）五种状态
- **运行态** Running：该时刻进程占用 CPU
- **就绪态** Ready：进程获得了**除处理机外的一切所需资源**，一旦得到处理机，就可以立即运行
- **阻塞态** Blocked：该进程正在等待某一事件发生而暂停运行，如等待某个资源可用（不包括 CPU）或等待 I/O 完成
- **创建态** New：进程正在被创建时的状态
- **结束态** Exit：进程正在从系统中消失时的状态

#### （2）状态转换
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240509150939.png)
- **就绪态 ---> 运行态**：
	- 进程被调度，获得处理机资源（分派处理机时间片）
- **运行态 ---> 就绪态**：
	- 时间片用完后，不得不让出处理机
	- 可剥夺的 OS 中，当有**更高优先级的进程就绪**时，调度程序将正在执行的进程转换为就绪态
- **运行态 ---> 阻塞态**：
	- 该过程是**主动行为**
	- 进程请求某一资源（如外设） 的使用和分配时
	- 等待某一事件的发送时（如 I/O 操作的完成）
	- 进程以**系统调用**的方式请求 OS 提供服务，这个过程系统从用户态转换为核心态
- **阻塞态 ---> 就绪态**：
	- 该过程是**被动行为**，需要其他相关进程的协助
	- I/O 操作结束或中断结束时
	- 发送了阻塞队列等待的事件，如发送了 V 操作，信号量+1，然后阻塞队列被唤醒到就绪队列中

### 3、进程控制
- **进程控制**：主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能
- **原语**：进程控制用的程序段【执行期间不允许中断，是一个不可分割的基本单位】
	- 可以用 “关中断指令”和“开中断指令”这两个特权指令实现原子性

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240509155911.png)

#### （1）进程的创建
##### 1）定义及过程
- 允许一个进程创建另一个进程
- 允许子进程继承父进程所拥有的资源
- **创建原语**：
	- 为新进程分配一个进程标识号，申请一个空白的 PCB【PCB 是有限的】
	- 为该进程分配运行时所必需的资源，如内存、文件、I/O 和 CPU 时间等
	- 初始化 PCB，如标志、状态、控制、优先级信息
	- 将 PCB 插入就绪队列

##### 2）对应事件
- **用户登录**：分时系统中，用户登录成功，系统会为其建立一个新的进程
- **作业调度**：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
- **系统提供服务**：用户向操作系统提出某些请求时，会建立一个进程处理该请求
- **用户程序的应用**：由用户进程主动请求创建一个子进程
- **注意**：设备分配不需要创建进程

#### （2）进程的终止
##### 1）定义及过程
- 当子进程被终止时，其在父进程处继承的资源应当还给父进程
- 当父进程被终止时，该父进程的子进程就变为孤儿进程
-  **终止原语**：
	- 查找需要终止的进程的 PCB
	- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程
	- 如果其还有子进程，全部终止
	- 将该进程所拥有的全部资源都归还给操作系统
	- 将其从 PCB 所在队列中删除

##### 2）对应事件
- **正常结束**：进程任务完成并自己准备退出运行
- **异常结束**：进程运行时发生了异常事件
- **外界干预**：如操作系统干预、父进程请求或父进程终止

#### （3）进程的阻塞
##### 1）定义及过程
- 当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待
- 一旦被阻塞等待，只能由另一个进程唤醒
- **阻塞原语**：
	- 找到将要被阻塞进程标识号对应的 PCB
	- 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行
	- 将该 PCB 插入到阻塞队列中去

##### 2）对应事件
- 需要等待系统系统分配某种资源
- 需要等待相互合作的其他进程完成工作

#### （4）进程的唤醒
##### 1）定义及过程
- 进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成
- 处于阻塞状态的进程是绝对不可能叫醒自己
- 如果某进程正在等待 I/O 事件，需由别的进程发消息给它
- 只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它
- **唤醒原语**：
	- 在该事件的阻塞队列中找到相应进程的 PCB
	- 将其从阻塞队列中移出，并置其状态为就绪状态
	- 把该 PCB 插入到就绪队列中，等待调度程序调度
- **注意**：阻塞原语和唤醒原语必须成对使用

##### 2）对应事件
- 等待的事件发生

### 4、进程的上下文切换
#### 1、基本概念
- **上下文**：指某一时刻 CPU 寄存器和 PC 的内容；如寄存器值，用户和系统内核栈内容
- **进程上下文切换**：指一个进程切换到另一个进程的过程
- 实质是处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化
- 有些处理器提供多个寄存器组，上下文切换**只需要简单改变当前寄存器组的指针，不需要用到磁盘和主存**

#### 2、上下文切换的场景
- 某个进程时间片耗尽时
- 进程在系统资源不足时，要等到资源满足后才可以运行
- 进程通过 sleep 将自己主动挂起
- 有优先级更高的基础运行时
- 发送硬件中断时

#### 3、上下文切换的流程
1. 挂起一个进程，保存 CPU 上下文，包括 PC 和其他寄存器
2. 更新 PCB 信息
3. 把进程的 PCB 移到相应的队列（如就绪队列，阻塞队列）
4. 加载另一个进程执行，更新其 PCB
5. 跳转到新进程 PCB 中的 PC 所指向的位置执行
6. 恢复处理机上下文
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240510140821.png)

#### 4、调度和切换的区别
- **先有资源的调度，才有进程的切换**
- 调度：决定资源分配给哪个进程的行为；是一种**决策**行为
- 切换：实际分配的行为；是一种**执行**行为

### 5、进程通信
- **进程通信**：指进程之间的信息交换
- 各进程拥有的内存地址空间相互独立
- 为了保证安全，一个进程不能直接访问另一个进程的地址空间
#### （1）低级通信方式
- PV 操作
#### （2）高级通信方式
##### 1）共享存储
- 设置一个共享内存区域，并映射到进程的虚拟地址空间
- 要**互斥地访问**共享空间【通信进程自己负责实现】
- **基于数据结构的共享**：
	- 比如共享空间里只能放一个长度为 10 的数组
	- 速度慢、限制多
	- 是一种低级通信方式
- **基于存储区的共享**：
	- 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统
	- 灵活性高、速度快
	- 是一种高级通信方式

##### 2）信息传递
- 进程间的数据交换以**格式化的消息**（Message）为单位
- 进程通过操作系统提供的“**发送消息/接收消息”两个原语**进行数据交换
- 隐藏了通信实现细节，对用户透明，简化了通信程序的设计
- 应用最广泛
- **直接通信方式**：发送进程直接将消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从队列取得消息
- **间接通信方式**：发送进程将消息发送给某个中间实体【信箱】

##### 3）管道通信
- 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输【如果要实现**双向同时通信**，则需要设置**两个管道**】
- 各进程要**互斥**地访问管道【由操作系统实现】
- 当**管道写满**时，**写进程将阻塞**，直到读进程将管道中的数据取走，即可唤醒写进程
- 当**管道读空**时，**读进程将阻塞**，直到写进程往管道中写入数据，即可唤醒读进程
- 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱，解决方案：
	1. 一个管道允许多个写进程，一个读进程
	2. 允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）
- 管道是一种**特殊文件**，可以克服使用文件通信的两个问题：
	1. 限制管道的大小：管道文件是一个固定文件大小的缓冲区
	2. 读进程也可能工作得比写进程快
- 管道只能由创建进程访问【子进程可继承父进程的管道，并可用它来与父进程通信】
- 从管道读数据是**一次性操作**，数据一旦被读取，就释放空间以便写更多数据

### 6、线程和多线程模型
#### （1）线程的基本概念
- 线程可理解为轻量级进程
- 线程是一个**基本的 CPU 执行单元**，也是**程序执行流的最小单位**
- 引入线程后的变化：
	- **并发性**：进程内的各线程之间也可以并发，从而进一步提升了系统的并发度
	- **资源分配、调度**：进程是资源分配的基本单位，线程是处理机调度的基本单位
	- **系统开销**：线程间并发，如果是同一进程内的切换，则不需要切换进程环境，系统开销小
- 多 CPU 计算机中，各个线程可占用不同的 CPU
- 每个线程都有一个唯一的标识符和一个线程控制块【记录线程执行的寄存器和栈等现场状态】
- 不同的线程可以执行相同的程序
- 线程也有**就绪、阻塞、运行**三种基本状态，和进程之间的转换是一样的
- 线程共享进程地址空间和资源，线程自己没有独立的地址空间

#### （2）线程的组成和控制
##### 1）线程控制块 TCB
- **功能**：每个线程配置一个 TCB，用于记录控制和管理线程的信息
- **组成**：
	- 线程标识符
	- 一组寄存器，包括程序计数器、状态寄存器和通用寄存器
	- 线程运行状态
	- 优先级
	- 线程专有存储区，线程切换时用于保存现场
	- 堆栈指针，用于过程调用时保存局部变量及返回地址

##### 2）线程的控制
- 创建线程：
	- 用户程序启动时，通常仅有一个称为**初始化线程**的线程正在执行，其主要功能是用于创建新线程
- 终止线程：
	- 通常，线程被终止后并**不立即释放**它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用
	- 被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行

#### （3）线程的实现方式
##### 1）用户级线程（ULT）
- 用户级线程由应用程序通过线程库实现，所有的**线程管理工作都由应用程序负责**（包括线程切换）
- 用户级线程中，**线程切换**可以在**用户态下即可完成**，无需操作系统干预
- 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在【“用户级线程”就是“**从用户视角看能看到的线程**”】
- **优点**：
	- 线程切换不需要转到内核空间，节省了模式切换的开销
	- 调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法
	- 与操作系统平台无关，对线程管理的代码是属于用户程序的一部分
- **缺点**：
	- 当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高
	- 不能发挥多 CPU 的优势，内核每次分配给一个进程的仅有一个 CPU，因此进程中仅有一个线程执行
- 形成**多对一模型**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511144229.png)

##### 2）内核级线程（KLT）
- **内核级线程的管理工作**由**操作系统内核**完成
- 内核级线程的切换必然需要在**核心态**下才能完成
- 操作系统会为每个内核级线程建立相应的TCB，通过 TCB 对线程进行管理【“内核级线程”就是“**从操作系统内核视角看能看到的线程**”】
- **优点**：
	- 能发挥多 CPU 的优势，内核能同时调度同一进程的多个线程并行执行
	- 如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用 CPU，也可以运行其他进程中的线程
	- 内核支持线程具有很小的数据结构和栈，线程切换快、开销小
	- 内核本身也可采用多线程技术，可以提高系统的执行速度和效率
- **缺点**：
	- 同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大【用户进程的线程在用户态执行，而线程调度和管理是在内核实现】
- 形成**一对一模型**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511145234.png)

##### 3）组合方式
- 内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程
- 用户级线程通过时分多路复用内核线程实现
- 结合 KLT 和 ULT 的优点，又克服各自的不足
- **线程库**：为程序员提供创建和管理线程的 API，实现方法：
	- 在用户空间中提供一个没有内核支持的库【调用库内的一个函数只导致用户空间中的一个本地函数的调用】
	- 实现由操作系统直接支持的内核级的一个库【调用库中的一个 API 函数通常会导致对内核的系统调用】
- 形成**多对多模型**
#### （4）多线程模型
- 由于用户级线程和内核级线程的连接方式不同，从而形成了三种不同的多线程模型
- 操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240511145328.png)
##### 1）多对一模型
- **定义**：多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程
- **优点**：
	- 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
- **缺点**：
	- 当**一个用户级线程被阻塞后，整个进程都会被阻塞**，并发度不高
	- 任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个CPU 上运行

##### 2）一对一模型
- **定义**：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程
- **优点**：
	- 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强
	- 多线程可在多核处理机上并行执行
- **缺点**：
	- 每创建一个用户线程，就要创建一个对应的内核线程，开销大
	- 线程切换由操作系统内核完成，需要切换到核心态，线程管理的成本高，开销大

##### 3）多对多模型
- **定义**：n 用户及线程映射到 m 个内核级线程（**n >= m**），每个用户进程对应 m 个内核级线程。
- 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点
- 用户级线程是“代码逻辑”的载体
- 内核级线程是“运行机会”的载体
- 一段“代码逻辑”只有获得了“运行机会”才能被CPU 执行
- 内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有所有内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞

## 二、CPU 调度


## 三、同步与互斥


## 四、死锁