## 一、内存管理概念
### 1、基本原理和要求
#### （1）基本概念
- **内存管理**：是操作系统对内存的划分和动态分配
- **目的**：
	- 为了更好地支持多道程序并发执行
	- 方便用户
	- 提高内存利用率
- **功能**：
	- **内存空间的分配与回收**：由 OS 完成主存储器空间的分配与管理
	- **地址转换**：存储管理将逻辑地址转换为物理地址
	- **内存空间的扩充**：利用虚拟存储技术从逻辑上扩充内存
	- **内存共享**：允许多个进程访问内存的同一部分
	- **存储保护**：保证多道作业在各自的存储空间运行，互不干扰
- **分配方式**：
	- **连续分配**：
		- 单一连续分配 ---> 固定分区分配【单道发展到多道 OS】 ---> 动态分区分配【为了适应大小不同的程序】
	- **不连续分配**：
		- 分页存储管理 ---> 分段存储管理 ---> 段页存储管理

#### （2）程序的链接与装入
- 创建进程首先要将程序和数据装入内存，将用户**源程序变为可在内存中执行的程序**，需要的步骤如下：
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514104221.png)
1. **编译**：由编译程序将用户源代码编译成若干目标模块
2. **链接**：由链接程序将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完整的装入地址，有三种方式：
	- **静态链接**：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514104926.png)

	- **装入时动态链接**：将各目标模块装入内存时，边装入边链接的链接方式
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514105049.png)

	- **运行时动态链接**：在程序执行中需要改目标模块时，才对它进行链接，优点时便于修改和更新，便于实现对目标模块的共享
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514105239.png)
3. **装入**：由装入程序将装入模块装入内存运行，有三种方式：
	- **绝对装入**：
		- 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码装入程序按照装入模块中的地址，将程序和数据装入内存
		- 程序中的逻辑地址与实际内存地址完全相同
		- 只适用于**单道程序环境**
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110017.png)

	- **可重定位装入**【静态重定位】：
		- 编译、链接后的**装入模块的地址都是从0开始**的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址
		- 装入时对地址进行“重定位”，将逻辑地址变换为物理地址【地址变换是在装入时一次完成的】
		- 装入时，必须给作业分配所要求的全部内存空间
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110246.png)

	- **动态运行时装入**【动态重定位】：
		- 编译、链接后的**装入模块的地址都是从 0 开始**的
		- 装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把**地址转换推迟到程序真正要执行时才进行**
		- 因此装入内存后所有的地址依然是逻辑地址
		- 这种方式需要一个**重定位寄存器**的支持
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110614.png)

#### （2）逻辑地址与物理地址
- **逻辑地址**【相对地址】：编译后，每个目标模块都从 0 号单元开始编址，这称为该目标模块的**逻辑地址**
- **逻辑地址空间**【虚拟地址空间】：链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始的编址空间【32 位系统，范围 0 ~ $2^{32}-1$ 】
- **物理地址空间**：内存中物理单元的集合，它是地址转换的最终地址
- **地址重定位**：装入程序将可执行代码装入内存时，将逻辑地址转换成物理地址的过程
- 不同进程可以有相同的逻辑地址，这些逻辑地址映射到主存的不同位置
- 进程运行时，看到和使用的是逻辑地址

#### （3）进程的内存映像
- 当一个进程调入内存运行时，就构成了进程的内存映像
- 组成要素：
	- **代码段**：程序的二进制代码【代码段是只读的，可以被多个进程共享】
	- **数据段**：程序运行时加工处理的对象，包括全局变量和静态变量
	- **进程控制块 PCB**：存放在系统区，OS 通过 PCB 控制和管理进程
	- **堆**：用来存放动态分配的变量【通过调用 malloc 函数动态地向高地址分配空间】
	- **栈**：用来实现函数调用的【从用户空间的最大地址往低地址方向增长】
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514112151.png)

#### （4）内存保护
- **目的**：确保每个进程都有一个单独的内存空间
- 方法一：在 CPU 设置一对**上、下限寄存器**，存放用户进程在主存中的上限和下限地址，判断 CPU 访问的地址是否越界
- 方法二：采用**重定位寄存器**（也称基址寄存器）和**界地址寄存器**（也称限长寄存器）
	- 重定位寄存器存放进程的起始物理地址
	- 界地址寄存器存放进程的最大逻辑地址
	- 逻辑地址 + 重定位寄存器的值 = 实际物理地址
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514113902.png)

#### （5）内存共享
- 只有**只读**区域的进程空间可以共享
- **可重入代码**【也称纯代码】：允许多个进程同时访问但不允许被任何进程修改的代码
- 可重入程序通过减少交换数量来改善系统性能
- 实现方式：段的共享，内存映射文件，基于共享内存的进程通信

### 2、内存空间的分配管理方式
#### （1）连续分配方式
- **定义**：为一个用户程序分配一个连续的内存空间
- **特点**：
	- 用户程序在主存中都是连续存放的
	- 存储密度大
- **外部碎片**：内存中产生的小内存块，存在于所有分区的外部
- **内部碎片**：分配给某进程的内存区域中，没有被用上的部分
##### 1）单一连续分配
- **定义**：内存被分为系统区与用户区
	- **系统区**：仅供 OS 使用，通常在低地址部分
	- **用户区**：内存中仅有一道用户程序
- **优点**：
	- 简单、**无外部碎片**
	- 不需要进行内存保护
- **缺点**：
	- 只能用于单用户、单任务的操作系统
	- **有内部碎片**
	- 存储器的利用率极低
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514120842.png)

##### 2）固定分区分配
- **定义**：将用户内存空间大小划分若干固定大小的分区，每个分区只装入一道作业
- **分区大小相等**：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合
- **分区大小不等**：增加了灵活性，可以满足不同大小的进程需求，根据常在系统中运行的作业大小情况进行划分
- 为了方便分配与回收，建立一张**分区使用表**，每个表项对应一个分区，包括分区大小、起始地址及状态
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514121528.png)
- **优点**：实现简单，**无外部碎片**
- **缺点**：
	- 程序太大可能放不下任何一个分区
	- 程序太小也要占用一个完整分区，**产生内部碎片**
	- 不能实现多进程共享一个主存区，存储空间利用率低

##### 3）动态分区分配
- **定义**：进程在装入内存时，根据进程的实际需要，动态地为之分配内存，并使分区的大小正好适合进程的需要
- **优点**：支持多道程序，**无内部碎片**
- **缺点**：**有外部碎片**【可通过**紧凑**技术处理】
- **回收内存分区**时，可能会遇到四种情况【原则：相邻的空闲分区要合并】：
	- 回收区之后有相邻的空闲分区
	- 回收区之前有相邻的空闲分区
	- 回收区前、后都要相邻的空闲分区
	- 回收区前、后都没有相邻的空闲分区
- 基于**顺序搜索**的分配算法：

| 算法   | 算法思想                      | 分区排列顺序                  | 优点                                  | 缺点                                              |
| ---- | ------------------------- | ----------------------- | ----------------------------------- | ----------------------------------------------- |
| 首次适应 | 从头到尾找适合的分区                | 空闲分区以地址递增次序排列           | 综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序 |                                                 |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区        | 空闲分区以容量递增次序排列           | 会有更多的大分区被保留下来，更能满足大进程需求             | 会产生很多太小的、难以利用的碎片，算法开销大，回收分区后可能需要对空闲分区队列重新排序     |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片  | 空闲分区以容量递减次序排列           | 可以减少难以利用的小碎片                        | 大分区容易被用完，不利于大进程，算法开销大（原因同上）                     |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列（可排列成循环链表） | 不用每次都从低地址的小分区开始检索，算法开销小（原因同首次适应）    | 内存低、高地址部分的空闲分区以同等概率被分配，划分为小分区，导致内存高地址部分没有大空闲区可用 |
- 基于**索引搜索**的分配算法【大、中型系统】：

| 算法     | 算法思想                                                                                                                                    | 优点            | 缺点                           |
| ------ | --------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------------------- |
| 快速适应算法 | 首先根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表；然后从链表中取出第一块进行分配                                                                                          | 查找效率高、不产生内部碎片 | 回收分区时，需要有效合并分区，算法比较复杂，系统开销较大 |
| 伙伴系统   | 规定所有分区的大小均为 2 的 k 次幂 [操作系统学习笔记（九）：连续内存分配——伙伴系统\_伙伴系统是一种内存分配算法,其特点是-CSDN博客](https://blog.csdn.net/djl806943371/article/details/90246313) |               |                              |
| 哈希算法   | 根据空闲分区链表的分区规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，每个表项记录一个对应空闲分区链的头指针。分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表                               |               |                              |
