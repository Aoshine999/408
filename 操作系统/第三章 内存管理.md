## 一、内存管理概念
### 1、基本原理和要求
#### （1）基本概念
- **内存管理**：是操作系统对内存的划分和动态分配
- **目的**：
	- 为了更好地支持多道程序并发执行
	- 方便用户
	- 提高内存利用率
- **功能**：
	- **内存空间的分配与回收**：由 OS 完成主存储器空间的分配与管理
	- **地址转换**：存储管理将逻辑地址转换为物理地址
	- **内存空间的扩充**：利用虚拟存储技术从逻辑上扩充内存
	- **内存共享**：允许多个进程访问内存的同一部分
	- **存储保护**：保证多道作业在各自的存储空间运行，互不干扰
- **分配方式**：
	- **连续分配**：
		- 单一连续分配 ---> 固定分区分配【单道发展到多道 OS】 ---> 动态分区分配【为了适应大小不同的程序】
	- **不连续分配**：
		- 分页存储管理 ---> 分段存储管理 ---> 段页存储管理

#### （2）程序的链接与装入
- 创建进程首先要将程序和数据装入内存，将用户**源程序变为可在内存中执行的程序**，需要的步骤如下：
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514104221.png)
1. **编译**：由编译程序将用户源代码编译成若干目标模块
2. **链接**：由链接程序将编译后形成的一组目标模块，以及它们所需的库函数链接在一起，形成一个完整的装入地址，有三种方式：
	- **静态链接**：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514104926.png)

	- **装入时动态链接**：将各目标模块装入内存时，边装入边链接的链接方式
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514105049.png)

	- **运行时动态链接**：在程序执行中需要改目标模块时，才对它进行链接，优点时便于修改和更新，便于实现对目标模块的共享
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514105239.png)
3. **装入**：由装入程序将装入模块装入内存运行，有三种方式：
	- **绝对装入**：
		- 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码装入程序按照装入模块中的地址，将程序和数据装入内存
		- 程序中的逻辑地址与实际内存地址完全相同
		- 只适用于**单道程序环境**
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110017.png)

	- **可重定位装入**【静态重定位】：
		- 编译、链接后的**装入模块的地址都是从0开始**的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址
		- 装入时对地址进行“重定位”，将逻辑地址变换为物理地址【地址变换是在装入时一次完成的】
		- 装入时，必须给作业分配所要求的全部内存空间
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110246.png)

	- **动态运行时装入**【动态重定位】：
		- 编译、链接后的**装入模块的地址都是从 0 开始**的
		- 装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把**地址转换推迟到程序真正要执行时才进行**
		- 因此装入内存后所有的地址依然是逻辑地址
		- 这种方式需要一个**重定位寄存器**的支持
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514110614.png)

#### （2）逻辑地址与物理地址
- **逻辑地址**【相对地址】：编译后，每个目标模块都从 0 号单元开始编址，这称为该目标模块的**逻辑地址**
- **逻辑地址空间**【虚拟地址空间】：链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始的编址空间【32 位系统，范围 0 ~ $2^{32}-1$ 】
- **物理地址空间**：内存中物理单元的集合，它是地址转换的最终地址
- **地址重定位**：装入程序将可执行代码装入内存时，将逻辑地址转换成物理地址的过程
- 不同进程可以有相同的逻辑地址，这些逻辑地址映射到主存的不同位置
- 进程运行时，看到和使用的是逻辑地址

#### （3）进程的内存映像
- 当一个进程调入内存运行时，就构成了进程的内存映像
- 组成要素：
	- **代码段**：程序的二进制代码【代码段是只读的，可以被多个进程共享】
	- **数据段**：程序运行时加工处理的对象，包括全局变量和静态变量
	- **进程控制块 PCB**：存放在系统区，OS 通过 PCB 控制和管理进程
	- **堆**：用来存放动态分配的变量【通过调用 malloc 函数动态地向高地址分配空间】
	- **栈**：用来实现函数调用的【从用户空间的最大地址往低地址方向增长】
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514112151.png)

#### （4）内存保护
- **目的**：确保每个进程都有一个单独的内存空间
- 方法一：在 CPU 设置一对**上、下限寄存器**，存放用户进程在主存中的上限和下限地址，判断 CPU 访问的地址是否越界
- 方法二：采用**重定位寄存器**（也称基址寄存器）和**界地址寄存器**（也称限长寄存器）
	- 重定位寄存器存放进程的起始物理地址
	- 界地址寄存器存放进程的最大逻辑地址
	- 逻辑地址 + 重定位寄存器的值 = 实际物理地址
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514113902.png)

#### （5）内存共享
- 只有**只读**区域的进程空间可以共享
- **可重入代码**【也称纯代码】：允许多个进程同时访问但不允许被任何进程修改的代码
- 可重入程序通过减少交换数量来改善系统性能
- 实现方式：段的共享，内存映射文件，基于共享内存的进程通信

### 2、内存空间的分配管理方式
#### （1）连续分配方式
- **定义**：为一个用户程序分配一个连续的内存空间
- **特点**：
	- 用户程序在主存中都是连续存放的
	- 存储密度大
- **外部碎片**：内存中产生的小内存块，存在于所有分区的外部
- **内部碎片**：分配给某进程的内存区域中，没有被用上的部分
##### 1）单一连续分配
- **定义**：内存被分为系统区与用户区
	- **系统区**：仅供 OS 使用，通常在低地址部分
	- **用户区**：内存中仅有一道用户程序
- **优点**：
	- 简单、**无外部碎片**
	- 不需要进行内存保护
- **缺点**：
	- 只能用于单用户、单任务的操作系统
	- **有内部碎片**
	- 存储器的利用率极低
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514120842.png)

##### 2）固定分区分配
- **定义**：将用户内存空间大小划分若干固定大小的分区，每个分区只装入一道作业
- **分区大小相等**：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合
- **分区大小不等**：增加了灵活性，可以满足不同大小的进程需求，根据常在系统中运行的作业大小情况进行划分
- 为了方便分配与回收，建立一张**分区使用表**，每个表项对应一个分区，包括分区大小、起始地址及状态
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514121528.png)
- **优点**：实现简单，**无外部碎片**
- **缺点**：
	- 程序太大可能放不下任何一个分区
	- 程序太小也要占用一个完整分区，**产生内部碎片**
	- 不能实现多进程共享一个主存区，存储空间利用率低

##### 3）动态分区分配
- **定义**：进程在装入内存时，根据进程的实际需要，动态地为之分配内存，并使分区的大小正好适合进程的需要
- **优点**：支持多道程序，**无内部碎片**
- **缺点**：**有外部碎片**【可通过**紧凑**技术处理】
- **回收内存分区**时，可能会遇到四种情况【原则：相邻的空闲分区要合并】：
	- 回收区之后有相邻的空闲分区
	- 回收区之前有相邻的空闲分区
	- 回收区前、后都要相邻的空闲分区
	- 回收区前、后都没有相邻的空闲分区
- 基于**顺序搜索**的分配算法：

| 算法   | 算法思想                      | 分区排列顺序                  | 优点                                  | 缺点                                              |
| ---- | ------------------------- | ----------------------- | ----------------------------------- | ----------------------------------------------- |
| 首次适应 | 从头到尾找适合的分区                | 空闲分区以地址递增次序排列           | 综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序 |                                                 |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区        | 空闲分区以容量递增次序排列           | 会有更多的大分区被保留下来，更能满足大进程需求             | 会产生很多太小的、难以利用的碎片，算法开销大，回收分区后可能需要对空闲分区队列重新排序     |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片  | 空闲分区以容量递减次序排列           | 可以减少难以利用的小碎片                        | 大分区容易被用完，不利于大进程，算法开销大（原因同上）                     |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列（可排列成循环链表） | 不用每次都从低地址的小分区开始检索，算法开销小（原因同首次适应）    | 内存低、高地址部分的空闲分区以同等概率被分配，划分为小分区，导致内存高地址部分没有大空闲区可用 |
- 基于**索引搜索**的分配算法【大、中型系统】：

| 算法     | 算法思想                                                                                                                                    | 优点            | 缺点                           |
| ------ | --------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------------------- |
| 快速适应算法 | 首先根据进程的长度，在索引表中找到能容纳它的最小空闲分区链表；然后从链表中取出第一块进行分配                                                                                          | 查找效率高、不产生内部碎片 | 回收分区时，需要有效合并分区，算法比较复杂，系统开销较大 |
| 伙伴系统   | 规定所有分区的大小均为 2 的 k 次幂 [操作系统学习笔记（九）：连续内存分配——伙伴系统\_伙伴系统是一种内存分配算法,其特点是-CSDN博客](https://blog.csdn.net/djl806943371/article/details/90246313) |               |                              |
| 哈希算法   | 根据空闲分区链表的分区规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，每个表项记录一个对应空闲分区链的头指针。分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表                               |               |                              |

#### （2）基本分页存储管理
##### 1）分页思想
- 将内存空间分为若干固定大小（如 4 KB）的分区，称为**页框**、**页帧**或**物理块**
- 内存空间中的每个页框有一个编号，称为**页框号**、**物理块号**，从 0 开始
- 进程的逻辑地址空间也分为**与块大小相等**的若干区域，称为**页**或**页面**
- 进程的逻辑地址空间中的每个页面有一个编号，称为**页号**，从 0 开始
- 进程在执行时需要申请内存空间，即要为每个页面分配内存中的可用页框，形成一一对应的关系
- **特点**：
	- 不产生外部碎片
	- 产生内部碎片（很小）
	- 分页是面向计算机的

##### 2）页表
- 为了能知道进程的每个页面在内存中存放的位置，OS 要为**每个进程建立一张页表**
- 进程的每个页面对应一个**页表项**
- 每个页表项由**页号**和**块号**组成【大小相同】，记录了页面在内存中对应的物理块号
- 页表项连续存放，因此页号可以是隐含的，不占用存储空间【i 号页表项存放地址=页表始址 + i * 页表项大小】
- 页表的作用是实现从**页号到物理块号的地址映射**
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514195528.png)
- 计算：每个页表项占多少字节？
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514201010.png)

##### 3）地址结构
- 页号 + 页内偏移量
	![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514194129.png)
- 如果有 K 位表示“页内偏移量”，则说明该系统中，**一个页面的大小是 $2^K$ 个内存单元**
- 如果有 M 位表示“页号”，则说明在该系统中，**一个进程最多允许有 $2^M$ 个页面**
- 地址结构决定了虚拟内存的寻址空间有多大
- **页号** = 逻辑地址 / 页面长度（取除法的**整数**部分）
- **页内偏移量** = 逻辑地址 % 页面长度（取除法的**余数**部分）
- **页面大小刚好是 2 的整数幂有什么好处？**
	- 逻辑地址的拆分更加迅速：如果每个页面大小为 $2^k$ B，用二进制数表示逻辑地址，则不需要除法运算可知，末尾 k 位为页内偏移量，其余部分是页号
	- 物理地址的计算更加迅速：根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可得到最终的物理地址
- **页面太小**会使进程的页面数过多，页表过长，占用大量内存，增加硬件地址转换的开销，降低页面换入/换出的效率
- **页面太大**会使页内碎片增多，降低内存的利用率

##### 4）基本地址变换机构
- **任务**：将逻辑地址转换为内存中的物理地址
- **页表寄存器（PTR）**：
	- 存放页表在内存的始址 F 和页表长度 M
	- 单 CPU 系统中只设置一个
	- 进程未执行时，F 和 M 存放在本进程的 PCB 中；当进程被调度执行时，将装入 PTR
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514202615.png)
- 设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：
	1. 计算页号 P = A / L、页内偏移量 W = A % L
	2. 判断页号是否越界：若 P >= M，产生越界中断，否则，继续执行
	3. 在页表中查询页号对应的页表项，确定页面存放的物理块号【页号 P 对应的页表项地址 = F + P * 页表项长度，取出该页表项内容 b，即为物理块号 】
	4. 计算物理地址 E = b * L + W，并用物理地址访存【页面在内存中的始址 = b * L 】
- 整个地址变换过程均由**硬件自动完成**
- 页式管理中地址空间是**一维**的
- **两次访存**：
	- 第一次：访问页表，确定所存取的数据或指令的物理地址
	- 第二次：访问目标内存单元

##### 5）具有快表的地址变换机构
- **快表（TLB）**【相联存储器】：
	- 具有并行查找能力的高速缓冲存储器
	- 用来存放当前访问的若干页表项，以加速地址变换的过程
	- 基于局部性原理
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514205038.png)
1. 计算页号、页内偏移量
2. 检查页号合法性
3. **查快表**，若找到匹配的页号，直接读出对应的物理块号，**一次访存**
4. 若没有找到，访问主存的页表，读出页表项后，同时将其存入快表，**两次访存**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514205530.png)

##### 6）两级页表
- **逻辑地址结构**：一级页号 + 二级页号 + 页内偏移量
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514210155.png)
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514210216.png)
- 在页表的每个表项中，存放的是进程的某页对应的物理块号
- 在外层页表（页目录）的每个表项中，存放的是每个页表分页的始址
- 需要增设一个**外层页表寄存器**【页目录基址寄存器】，用于**存放页目录始址**
- 利用页目录和页表实现从逻辑地址到物理地址的转换：
	- 从 PCB 中读出页目录表始址
	- 根据**页目录号**查页目录表，从而找到对应页表的地址【第一次访存】
	- 根据**二级页号**查页表，从而找到对应的页表项【第二次访存】
	- 将页表项中的物理块号和页内偏移量拼接，即为物理地址，再访问对应内存单元【第三次访存】
- **注意**：一般来说**各级页表的大小不能超过一个页面**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240514212622.png)
- 若没有快表机构，N 级页表访问一个逻辑地址需要 N + 1 次访存