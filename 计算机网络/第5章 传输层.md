
## 一、传输层概述
### 1、基本概念
![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112211434828.png)
- **物理层、数据链路层以及网络层**它们共同解决了将主机通过异构网络互联起来所面临的的问题，**实现了主机到主机的通信**
- 实际上在**计算机网络中进行通信的真正实体是位于通信两端主机中的进程**
- 为运行在不同主机上的**应用进程提供直接的通信服务是传输层的任务**
- 传输层协议又称端到端协议
![image-20231112211504435](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112211504435.png)

### 2、传输层的功能
#### （1）应用进程之间的通信
![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112212642802.png)

#### （2）复用和分用
- **复用**：发送方不同的应用进程都可以使用同一传输层协议**传输数据**
- **分用**：接收方的传输层在剥去报文的首部之后能够把这些**数据正确交付到目的应用进程**
![image-20231112212729630](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112212729630.png)

![image-20231112212738803](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112212738803.png)
- **注意**：
	- **网络层的复用**：发送方不同协议的数据都可被封装成 IP 数据报发送出去
	- **网络层的分用**：接收方的网络层在剥去首部后把数据交付给相应的协议

#### （3）差错检测
- **网络层只检查 IP 数据的首部**，不检验数据部分
- **传输层对报文（首部和数据部分）**进行差错检测

#### （4）提供面向连接和无连接的传输协议
- **面向连接的 TCP 协议**：为其上层提供的是面向连接的可靠的数据传输服务
- **无连接的 UDP 协议**：为其上层提供的是无连接的不可靠的数据传输服务
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240718144059.png)

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240718151025.png)

- **注意**：
	- 网络层无法同时实现两种协议，即要么只提供面向连接的服务【如虚电路】，要么只提供无连接服务【如数据报】，而不可能在网络层中同时存在这两种形式
	- **IP 数据报和 UDP 数据报的区别**：
		- IP 数据报在网络层要**经过路由器的存储转发**
		- UDP 数据报在传输层的端到端的逻辑信道中传输，封装成 IP 数据报在网络层传输时，**UDP数据报的信息对路由器是不可见的**
	- **TCP 和网络层虚电路的区别**：
		- TCP 报文段在传输层抽象的逻辑信道中传输，对路由器不可见
		- 虛电路所经过的交换结点都必须保存虚电路状态信息
		- 在网络层若采用虚电路方式，则无法提供无连接服务
		- 传输层采用 TCP 不影响网络层提供无连接服务

### 3、传输层的寻址与端口
#### （1）端口的作用
- **端口**：
	- 传输层服务访问点（TSAP）
	- 能让应用层的各种进程将其数据通过端口向下交付给传输层
	- 让传输层知道应当将其报文段的数据向上通过端口交付给应用层相应的进程
![image-20231112213036420](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213036420.png)

#### （2）端口号
- 运行在计算机上的进程是使用**进程标识符 PID**来标识的
	- 因特网上的计算机并不是使用统一的操作系统，**不同的操作系统使用不同格式的进程标识符**
	- 为了使运行不同操作系统的计算机的应用进程之间能进行网络通信，必须**使用统一的方法对 TCP/IP 体系的应用进程进行标识，即端口号**
- **端口号只具有本地意义**，即端口号只是为了标识本计算机应用层中的各进程
- 在因特网中，**不同计算机中的相同的端口号是没有联系的**
- TCP 和 UDP 端口号之间也是没有关系的
- 端口号使用**16 比特**表示，取值范围 `0~65535`，根据端口号范围将端口分为两类：
	1. **服务端使用端口号**：
		- **熟知端口号**：`0~1023`，`IANA` 把这些端口号指派给了 `TCP/IP` 体系中最重要的一些应用协议，让所有用户都知道
		- **登记端口号**：`1024~49151`，为没有熟知端口号的应用程序使用，必须在 `IANA` 按照规定的手续登记，以防止重复【如 `Microsoft RDP` 微软远程桌面使用的端口是 `3389` 】
		![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240718150249.png)
	2. **客户端使用端口号**：`49152~65535`
		- 仅在客户进程运行时才动态地选择，又称**短暂（临时）端口号**
		- 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的的动态端口号
		- **通信结束后，这个端口号可供其他客户进程以后使用**

#### （3）套接字
- **套接字**：
	- 实际上是一个通信端点
	- 唯一地标识网络中的一台主机上的一个应用进程

$$
套接字Socket=（IP地址：端口号）
$$


## 二、UDP 协议
### 1、UDP 数据报
#### （1）UDP 概述
- UDP 仅在 IP 的数据报服务之上增加了两个最基本的服务：**复用和分用，差错检测**
- **特点**：
	- **无须建立连接**
	- **无连接状态**：当某些专用服务器使用 UDP 时，一般都能支持更多的活动客户机
	- **首部开销小**：仅有 8 B 
	- **没有拥塞控制**，网络中的拥塞不会影响源主机的发送速率
	- **支持单播、多播和广播**
	- **不保证可靠交付**：可靠性由用户在应用层维护
	- **面向应用报文**：收到应用层报文后直接为报文添加 UDP 首部就进行发送
- **适用场景**：
	- 一次性传输较少数据的网络应用【DNS、SNMP 等】
	- 多媒体应用【IP 电话、实时视频会议、流媒体等】

#### （2）UDP 首部格式
- UDP 数据报包含两部分：
	- **首部**：8 B
	- **数据部分**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240719165719.png)
- **源端口和目的端口**：
	- UDP 分用：基于目的端口
	- UDP 复用：基于源端口
	- 目的端口号不正确：丢弃报文，并有 ICMP 发送“端口不可达”差错报文给发送方
- **长度**：包括首部和数据，最小是 `8` 【仅有首部】
- **校验和（可选）**：
	- 检测 UDP 数据报是否有错，有就丢弃
	- 当源主机不想计算校验和时，令该字段为全 0

### 2、UDP 校验
- UDP 检验和提供差错检测功能
- 在计算校验和时，要在 UDP 用户数据报之前增加 **12 B的伪首部**【既不向下传送也不向上递交】
- **源 IP 地址和目的 IP 地址**：和 IP 数据一样，各占 4 B
- 伪首部**第 3 个字段是全 0**
- **协议字段**：值是 17
- **UDP 长度**：UDP 用户数据报长度【首部长度和数据部分长度之和】
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240719170518.png)
- **校验过程**：
	- **将校验和字段置位 0**
	- 将伪首部和 UDP 用户数据报【首部和数据部分】看成是以 16 位为单位的二进制组成，依次进行**二进制反码求和**
	- 将求和的**结果的反码写入校验和字段**
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240719170852.png)
- **注意**：
	- 检验时，若 UDP 数据报部分的长度不是偶数个字节，则需填入一个全 0 字节【此字节和伪首部一样，是不发送的】
	- 若 UDP 检验和检验出 UDP 数据报是错误的，则可以丢弃，也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报
	- 通过伪首部，不仅可以检查源端口号、目的端口号和 UDP 用户数据报的数据部分，还可以检查 IP 数据报的源 IP 地址和目的地址。


## 三、TCP 协议

### 概述

TCP 是在不可靠的 IP 层之上实现的可靠传输协议

+ `TCP` 是**面向连接**的

  > 发送数据前需要"三报文握手"建立连接，数据传输结束后需要"四报文挥手"释放连接

+ **仅支持单播**

  > 每一条 TCP 连接是点对点（一对一）的

+ **提供全双工通信**

  > TCP 连接的两端都设有发送缓存和接收缓存

+ `TCP` 是**面向字节流**的

  > 虽然实际上 TCP 的交互是数据块之间，但是 TCP 其将应用进程交付下来的数据块（报文段）仅仅看作是一连串的字节流

### TCP 的首部格式

TCP 传送的数据单元称为报文段。TCP 报文段既可以用来运载运载数据，又可以用来建立连接、释放连接和应答

TCP 首部最短是 `20B`，后面有 `4N` 字节是可选的

![image-20231125164227424](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125164227424.png)

+ **源端口**：占 `16` 比特，写入源端口号，用来**标识发送该 TCP 报文段的应用进程**

+ **目的端口**：占 `16` 比特，写入目的端口号，用来**标识接收该 TCP 报文段的应用进程**

+ **序号**：占 `32` 比特，取值范围 $[0,2^{32}-1]$

  序号增加到最后一个后，下一个序号就又回到 `0`。作用是**指出本 TCP 报文段数据载荷的第一个字节的序号**

+ **确认标志位 ACK**：取值为 `1` 时确认号字段才有效，为 `0` 时确认号字段无效

  `TCP` 规定：在 TCP 连接建立后，所有传送的 TCP 报文段都必须把 ACK 置 `1`

+ **确认号**：占 `32` 比特，取值范围 $[0,2^{32}-1]$

  序号增加到最后一个后，下一个序号就又回到 `0`。可理解为**若确认号=n，则表明到序号 n-1 为止的所有数据都已正确接收，期望接收序号为 n 的数据**

+ **数据偏移**：占 `4` 比特，并**以 4 字节为单位**

  用来指出 `TCP` 报文段的数据载荷部分的起始处距离 `TCP` 报文段的起始处。这个字段**实际上是指出 TCP 报文段的首部长度**

  **首部固定长度为 20 字节，因此数据偏移字段的最小值 (0101)；首部最大长度为 60 字节，因此数据偏移字段最大值为 (1111)**

+ **保留字段**：占**6 比特**，保留为今后使用，但是目前应置为 `0`

+ **窗口**：占**16 比特**，以字节为单位

  指出发送本报文段的一方的**接收窗口的大小**，即接收缓存的可用空间大小，这用来表征接收方的**接收能力**

  在计算机网络中，经常**用接收方的接收能力的大小来控制发送方的数据发送量**，这就是所谓的**流量控制**

+ **检验和**：占**16 比特**，检测范围**包括 TCP 报文段的首部和数据载荷两部分**

  在计算校验和时，要在 `TCP` 报文段的前面加上 `12` 字节的伪首部

+ **同步标志位 SYN**：在 `TCP`**连接建立**时用来同步序号

  当**SYN=1 且 ACK=0**时，表明这是一个 TCP 连接请求报文段

  对方若同意建立连接，则在**响应的 TCP 报文段**的首部中使**SYN=1 且 ACK=1**

  综上，SYN=1 的 TCP 报文段要么是一个连接请求报文段，要么是一个连接响应报文段

+ **终止标志位 FIN**：用来**释放 `TCP` 连接**

  当 `FIN=1` 时，表明此 TCP 报文段的发送方已将全部数据发送完毕，现在要求**释放 TCP 连接**

+ **复位标志位 RST**：用来**复位 `TCP` 连接**

  当 `RST=1` 时，表明 `TCP` 连接出现了异常，必须释放连接，然后再重新建立连接；`RST` 置 `1` 还用来拒绝一个非法的报文段或拒绝打开一个 `TCP` 连接

+ **推送标志位 PSH**：接收方的 `TCP` 收到该**标志位为 1 的报文段会尽快上交应用进程**，而不必等到接收缓存都填满后再向上交付

+ **紧急标志位 URG**：取值**为 1**时**紧急指针字段有效**；取值为 `0` 时紧急指针字段无效。

+ **紧急指针**：占 `16` 比特，以字节为单位，用来指明紧急数据的长度

  当**发送方有紧急数据**时，可**将紧急数据插队到发送缓存的最前面**，并立刻封装到一个 `TCP` 报文段中进行发送。**紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据**，紧急数据之后是普通数据

  **接收方收到紧急标志位为 1 的 TCP 报文段**，会按照紧急指针字段的值从报文段数据载荷中取出**紧急数据**并直接上交应用进程，而**不必在接收缓存中排队**

+ **选项**：增加选项可以增加 `TCP` 的功能

  + **最大报文段长度 MSS 选项**：`TCP` 报文段数据载荷部分的最大长度
  + **窗口扩大选项**：为了扩大窗口 (提高吞吐率)
  + **时间戳选项**：
    + 用来计算往返时间 `RTT`
    + 用于处理序号超范围的情况，又称为防止序号绕回 `PAWS`
  + **选择确认选项**：实现选择确认功能

+ **填充**：由于选项长度可变，因此**使用填充来保证报文段首部能被 4 整除**

**MSS 设置的太大或者太小会有什么影响？**



**检验和**

![image-20231112214531311](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214531311.png)

![image-20231112214536311](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214536311.png)

![image-20231112214544518](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214544518.png)

### “三次握手”建立 TCP 连接

- **TCP 是面向连接**的协议，它基于运输连接来传送 TCP 报文段
  - TCP 运输连接的建立和释放，是**每一次面向连接的通信中必不可少的过程**
- TCP 运输连接有以下三个阶段
  1. 通过**“三报文握手”来建立 TCP 连接**
  2. 基于已建立的 TCP**连接进行可靠的数据传输**
  3. 在数据传输结束后，还要通过“四报文挥手”来释放 TCP**连接**
- 三报文握手”**建立 TCP 连接的目的**在于解决以下三个主要问题
  1. 使 TCP 双方能够**确知对方的存在**
  2. 使 TCP 双方能够**协商一些参数**（例如最大报文段长度、最大窗口大小、时间戳选项等）
  3. 使 TCP 双方能够**对运输实体资源进行分配和初始化**。运输实体资源包括缓存大小、各状态变量、连接表中的项目等

**过程**

![image-20231125182827580](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125182827580.png)



![image-20231125182842890](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125182842890.png)

![image-20231125182926745](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125182926745.png)

1. **客户发送 TCP 连接请求报文段进入同步已发送状态**
   - TCP 连接请求报文段和 TCP 连接请求确认报文段首部中的同步标志位 SYN 的值必须设置为 1
   - 序号 seq 字段被设置了一个初始值 x，作为 TCP 客户进程所选择的初始序号
     - TCP 规定同步标志位 SYN 被设置为 1 的报文段（例如 TCP 连接请求报文段和 TCP 连接请求确认报文段）不能携带数据，但要消耗掉一个序号。因此，**TCP 连接请求报文段不能携带数据（即没有数据载荷），但是会消耗掉序号 x**
     - TCP 客户进程下一次发送的 TCP 报文段的数据载荷的第一个字节的序号为 x+1
2. **服务器发送 TCP 连接请求确认报文段进入同步已接收状态**
   - TCP 连接请求确认报文段首部中的同步标志位 SYN 和确认标志位 ACK 的值都设置为 1
   - 序号 seq 字段被设置了一个初始值 y，作为 TCP 服务器进程所选择的初始序号
     - TCP 规定同步标志位 SYN 被设置为 1 的报文段（例如 TCP 连接请求报文段和 TCP 连接请求确认报文段）不能携带数据，但要消耗掉一个序号
   - 确认号 ack 字段的值被设置为 x+1，这是对 TCP 客户进程所选择的初始序号 x 的确认
3. **客户发送针对 TCP 连接请求确认报文段的普通 TCP 确认报文段，并进入连接已建立状态**
   - 确认标志位 ACK 的值被设置为 1，表明这是一个普通的 TCP 确认报文段
   - 因为 TCP 客户进程之前发送的 TCP 连接请求报文段的序号为 x，该报文段虽然不能携带数据，但要消耗掉一个序号。因此 TCP 客户进程发送的第二个报文段的序号为 x+1
   - 确认号 ack 字段的值被设置为 y+1，这是对 TCP 服务器进程所选择的初始序号 y 的确认

> 注意：
>
> 服务端的资源是完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的

**使用“三报文握手”而不是“两报文握手”的原因**

> 采用“三报文握手”而不是“两报文握手”来建立 TCP 连接，是为了防止已失效的 TCP 连接请求报文段突然又传送到了 TCP 服务器进程，因而导致错误。
>
> ![image-20231125183650330](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125183650330.png)

#### 例题

![image-20231112214125483](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214125483.png)

![image-20231112214131362](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214131362.png)

### “四报文挥手”释放 TCP 连接

![image-20231125183959949](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125183959949.png)

1. **客户发送 TCP 连接释放报文段并进入终止等待 1 状态**
   - TCP 连接释放报文段首部中的终止标志位 FIN 和确认标志位 ACK 的值都被设置为 1。表明这是一个 TCP 连接释放报文段，同时也对之前收到的 TCP 报文段进行确认
   - 序号 seq 字段的值设置为 u，它等于 TCP 客户进程之前已经传送过的数据的最后一个字节的序号加 1
     - TCP 规定终止标志位 FIN 等于 1 的 TCP 报文段即使不携带数据，也要消耗掉一个序号
   - 确认号 ack 字段的值设置为 v，它等于 TCP 客户进程之前已收到的数据的最后一个字节的序号加 1
   
2. **服务器发送 TCP 普通确认报文段并进入关闭等待状态**
- 确认标志位 ACK 的值被设置为 1，表明这是一个 TCP 普通确认报文段
   - 序号 seq 字段的值设置为 v，它等于 TCP 服务器进程之前已传送过的数据的最后一个字节的序号加 1。这也与之前收到的 TCP 连接释放报文段中的确认号 v 匹配
   
- 确认号 ack 字段的值设置为 u+1，这是对 TCP 连接释放报文段的确认

> ![image-20231125184320387](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125184320387.png)
>
> **此时的 TCP 连接属于半关闭状态**
>
> - TCP 客户进程已经没有数据要发送了。但 TCP 服务器进程如果还有数据要发送，TCP 客户进程仍要接收，也就是从 TCP 服务器进程到 TCP 客户进程这个方向的连接并未关闭
> - 半关闭状态可能会持续一段时间

3. **服务器发送 TCP 连接释放报文段并进入最后确认状态**
   - TCP 连接释放报文段首部中的终止标志位 FIN 和确认标志位 ACK 的值都被设置为 1。表明这是一个 TCP 连接释放报文段，同时也对之前收到的 TCP 报文段进行确认
   - 序号 seq 字段的值假定被设置为 w，这是因为在半关闭状态下 TCP 服务器进程可能又发送了一些数据
   - 确认号 ack 字段的值被设置为 u+1，这是对之前收到的 TCP 连接释放报文段的重复确认
4. **客户发送 TCP 普通确认报文段并进入时间等待状态**
   - 确认标志位 ACK 的值设置为 1，表明这是一个 TCP 普通确认报文段
   - 序号 seq 字段的值设置为 u+1，这是因为 TCP 客户进程之前发送的 TCP 连接释放报文段虽然不携带数据，但要消耗掉一个序号
   - 确认号 ack 字段的值设置为 w+1，这是对所收到的 TCP 连接释放报文段的确认

**为什么客户机还要要等到一段时间 `2MSL` 后完全关闭？**

> * 处于时间等待（TIME-WAIT）状态后要经过 2 MSL 时长，可以确保 TCP 服务器进程能够收到最后一个 TCP 确认报文段而进入关闭（CLOSED）状态
> * 另外，TCP 客户进程在发送完最后一个 TCP 确认报文段后，再经过 2 MSL 时长，就可以使本次连接持续时间内所产生的的所有报文段都从网络中消失。这样就可以使下一个新的 TCP 连接中不会出现旧连接中的报文段
>
> ![image-20231112214216285](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214216285.png)

**TCP 保活计时器**

![image-20231112214243597](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214243597.png)

#### 例题

![image-20231112214257037](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214257037.png)

![image-20231112214302825](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214302825.png)

![image-20231112214557534](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214557534.png)

![image-20231112214605097](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214605097.png)

![image-20231112214611034](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214611034.png)

### **TCP 流量控制**

#### 基本概念

TCP 为应用程序提供了**流量控制**（Flow Control）机制，以**解决因发送方发送数据太快而导致接收方来不及接收，造成接收方的接收缓存溢出的问题**

![image-20231125185000606](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125185000606.png)

#### TCP 的流量控制方法

+ 发送方和接收方窗口保持一致，发送方窗口随着接收方窗口变化而变化 (通过确认报文 rwnd 告知发送方)
+ 发送方发送完窗口内数据后需要等到确认报文才会滑动窗口并继续发送，若窗口内的某个值很久没有收到回答报文，则超时重传报文

![image-20231112213552925](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213552925.png)

![image-20231125191619874](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125191619874.png)

**若接收方窗口调为 0 后，一段时间之后又调为 200，此时向发送方传递确认报文，可此时报文丢失，则会造成发送方窗口始终为 0，接收方以为发送方收到了确认报文而开始等待数据，造成死锁，如何解决？**

> 当发送方窗口大小为 `0` 时，其隔一段时间（持续计时器）就会发送一个 `1` 字节大小的零窗口探测报文，看看此时接收窗口大小是否进行调整

**若发送的零窗口探测报文也丢失了，会造成新死锁吗？**

> 不会。因为零窗口探测报文也有超时重传机制
>
> ![image-20231125191542864](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125191542864.png)

#### 例题

![image-20231125191811976](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125191811976.png)

### TCP 拥塞控制

#### 拥塞控制的基本概念

- 在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏**，这种情况就叫作**拥塞**（congestion）
- 若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**

![image-20231125192025996](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125192025996.png)

#### 流量控制与拥塞控制的区别

- 流量控制
  - 以**接收方的接收能力**控制发送方（源点）的发送速率
  - 只与特定的点对点通信的发送方和接收方之间的流量有关
- 拥塞控制
  - **源点根据各方面因素**，按拥塞控制算法**自行控制发送速率**
  - 全局性问题，涉及网络中所有的主机、路由器等

#### 基本方法

1. **开环控制**

- 试图用良好的设计来解决问题
- 从一开始就保证问题不会发生
- 一旦系统启动并运行起来，就不需要中途修正
- 当网络的流量特征可以准确规定且性能要求可以事先获得时，适合使用开环控制

2. **闭环控制**

- 基于反馈的控制方法，包括以下三个部分
  - 监测网络拥塞在何时、何地发生
  - 把拥塞发生的相关信息传送到可以采取行动的地方
  - 调整网络的运行以解决拥塞问题
- 当网络的流量特征不能准确描述或者当网络不提供资源预留时，适合使用闭环控制。
  因特网采用的就是闭环控制方法

**衡量网络拥塞的指标**

![image-20231125193818294](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231125193818294.png)

根据**拥塞信息的反馈形式**，可将**闭环拥塞控制算法**分为

1. **显示反馈算法**

   **从拥塞节点（即路由器）向源点**提供关于网络中拥塞状态的显式反馈信息

2. **隐式反馈算法**

   **源点自身**通过对网络行为的观察（例如超时重传或往返时间 RTT）来推断网络是否发生了拥塞。**TCP 采用的就是隐式反馈算法**

进行**拥塞控制是需要付出代价的**

- 可能需要在节点之间**交换信息和各种命令**，以便选择拥塞控制的策略并实施控制，这样会产生额外开销
- 可能需要**预留一些资源**用于特殊用户或特殊情况，这样就降低了网络资源的共享程度

#### 慢开始和拥塞避免（TCP 连接建立和网络出现超时） ####

+ 发送方维护一个叫做**拥塞窗口 cwnd**的状态变量，**其值取决于网络的拥塞程度，并且动态变化**

  + `拥塞窗口cwnd` 的维护原则：**只要网络没有出现拥塞，拥塞窗口就再增大一些 (确认报文段窗口大小)，但只要网络出现拥塞，拥塞窗口就减少一些**
  + 判断出现网络拥塞的依据：没有按时收到应当到达的确认报文 (发送超时重传)

  ![image-20231112213614760](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213614760.png)

+ 发送方将拥塞窗口作为**发送窗口 swnd**，即 `swnd=cwnd`

+ 维护一个**慢开始门限 ssthresh**状态变量

  + 当 `cwnd < ssthresh` 时，使用慢开始算法

  + 当 `cwnd > ssthresh` 时，停止使用慢开始算法而改用拥塞避免算法

  + 当 `cwnd = ssthresh` 时，既可使用慢开始算法，也可以使用拥塞避免算法

> **拥塞窗口从 1 开始，根据应答报文大小来扩大拥塞窗口 (2 倍)**，如发送方窗口 `2`，应答大小 `2`，则下次发送大小为 `4`
>
> 这叫**慢开始算法**

> 当窗口增加到一定大小，发送方发送的报文出现了超时重传，则判断网络可能出现了拥塞，此时**将拥塞窗口初始化为 1**，同时将**慢开始门限 ssthresh 设置为发生拥塞时窗口大小的一半**，**拥塞窗口每次只扩大 1**，而不是向慢开始那样根据发送方的返回窗口进行增加。
>
> 这叫**拥塞避免算法**
>
> 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断出网络出现了拥塞，就要把 `ssthresh` 减半，把拥塞窗口 `cwnd` 重新设置为 1，重新执行慢开始算法

![image-20231112213633622](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213633622.png)

* “慢开始”是指一开始向网络注入的报文段少，而并不是指拥塞窗口 cwnd 的值增长速度慢
* “拥塞避免”也并非指完全能够避免拥塞，而是指在拥塞避免阶段将 cwnd 值控制为按线性规律增长，使网络比较不容易出现拥塞

> 在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法
>
> - “乘法减小”是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞)，就把慢开始门限值 ssthresh 设置为当前拥塞窗口的一半（并执行慢开始算法)。当网络频繁出现拥塞时, ssthresh 值就下降得很快，以大大减少注入网络的分组数
> - “加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个 RTT)，就把拥塞窗口 cwnd 增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞

#### 快重传和快恢复（发送方接收到冗余 ACK） ####

> 快重传是**使发送方尽快进行重传**，而不是等待超时重传计时器超时再重传

+ 要求**接收方不用等待**自己发送数据时才进行**捎带确认**，而是要**立即发送确认**
+ 即使**收到了失序的报文段 (说明有一段丢失了)**也要立即发出**对已收到的报文段的重复确认**
+ **发送方一旦收到 3 个连续的重复确认，就将相应的报文段立即重传**，而不是等该报文段的超时重传计时器超时再重传
+ 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞。使用快重传可以使整个网络的吞吐量提高约 `20%`

![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126161157284.png)

> 发送方一旦收到 `3` 个重复确认，就知道现在只是丢失了个别报文段，于是不启动慢开始算法，而执行**快恢复算法**

+ 发送方**将慢开始门限 ssthresh 值和拥塞窗口 cwnd 值调整为当前窗口的一半，开始执行拥塞避免算法**

+ 也有的快恢复实现是把快恢复开始时的拥塞窗口 `cwnd` 值再增大一些，即等于新的 `ssthresh+3`

  + 既然发送方收到 `3` 个重复的确认，就表明有 `3` 个数据报文段已经离开了网络
  + 这三个报文段不再消耗网络资源而是停留在接收方的接收缓存中
  + 可见现在网络中不是堆积了报文段而是减少了 `3` 个报文段。因此可以适当把拥塞窗口扩大些

  ![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126161312617.png)

> 由于跳过了拥塞窗口 `cwnd` 从 `1` 起始的慢开始过程，所以被称为**快恢复**

#### TCP 拥塞控制与网际层拥塞控制的关系

##### 尾部丢弃策略和全局同步

![image-20231112213927648](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213927648.png)

![image-20231112213933247](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213933247.png)

##### 主动队列管理

> 为了避免网络中出现全局同步问题，在 1998 年提出了**主动队列管理**（Active Queue Management，AQM）
>
> * 所谓“主动”，就是**在路由器的队列长度达到某个阈值但还未满时就主动丢弃 IP 数据报**，而不是要等到路由器的队列已满时才不得不丢弃后面到达的 IP 数据报，这样就太被动了
> * 应当在**路由器队列长度达到某个值得警惕的数值**时，也就是**网络出现了某些拥塞征兆**时，就**主动丢弃到达的 IP 数据报来造成发送方的超时重传**，进而**降低发送方的发送速率**，因而有可能**减轻网络的拥塞程度**，甚至不出现网络拥塞。
>
> 主动队列管理 AQM 可以有不同的实现方法，其中曾流行多年的就是随机早期检测（Random Early Detection，RED），也称为**随机早期丢弃**（Random Early Drop，RED 或 Random Early Discard，RED）
>
> * 路由器需要维护两个参数来实现 RED：**队列长度最小门限和最大门限**。当每一个 IP 数据报到达路由器时，RED 就按照规定的算法计算出当前的平均队列长度
>   - 若**平均队列长度小于最小门限**，则把新到达的 IP 数据报**存入**队列进行排队
>   - 若**平均队列长度大于最大门限**，则把新到达的 IP 数据报**丢弃**
>   - 若平**均队列长度在最小门限和最大门限之间**，则**按照某一丢弃概率 p 把新到达的 IP 数据报丢弃**（这体现了丢弃 IP 数据报的随机性）

#### TCP 可靠传输 ####

> - TCP 默认使用累计确认
>
> - TCP 的滑动窗口以字节为单位
>
> 注意：`ackn` 在选择重传协议与 TCP 协议中并不完全相同。
>
> - 在选择重传协议中， `ackn` 表明序号到 `n` 为止的数据已正确接收，现在期望收到序号为 `n+1` 的数据
> - 在 TCP 协议中， `ackn` 表明序号到 `n-1` 为止的数据已正确接收，现在期望收到序号为 `n` 的数据

![image-20231112214006145](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214006145.png)

应该如何描述发送窗口的状态呢？换句话说，如果要编程实现滑动窗口机制，那么对于发送窗口的状态应该如何标记和维护呢？

> **使用三个指针 P 1、P 2、P 3 分别指向相应的字节序号：**
>
> - P 1 指向发送窗口内已发送但还未收到确认的第一个数据的序号
> - P 2 指向发送窗口内还未发送的第一个数据的序号
> - P 3 指向发送窗口前沿外的第一个数据的序号

![image-20231112214012014](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112214012014.png)

1. 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口一样大**，这是因为：
   - 网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。
   - 发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。

2. **对于不按序到达的数据应如何处理，TCP 并无明确规定**
   - 如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。
   - TCP 通常对不按序到达的数据先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。

3. TCP 要求接收方**必须有累积确认（这一点与选择重传协议不同）**和**捎带确认机制**。这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。
   - 接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 1122]。
   - 捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

4. **TCP 的通信是全双工通信**。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。

#### TCP 超时重传时间 (RTO) 选择 ####

> 正常情况下，**超时重传时间应该设为略大于往返时间**。但是由于各区域的速率可能不一致，因此将超时重传时间设置为一个固定值是行不通的

![image-20231126163059047](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126163059047.png)
$$
利用每次测量得到的RTT样本，计算加权平均往返时间RTT_S(平滑的往返时间)
$$

$$
显然，超时重传时间RTO应略大于加权平均往返时间RTT_S
$$

![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126163117703.png)

**往返时间测量问题**

![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126163216908.png)

**针对出现超时重传时无法测准往返时间 RTT 的问题，有以下解决方法**

> - 在计算加权平均往返时间 $RTT_S$ 时，只要报文段重传了，就不采用其往返时间 `RTT` 样本。也就是**出现重传时，不重新计算 $RTT_S$，进而超时重传时间 RTO 也不会重新计算**。
>   - 此方法的漏洞如下：如果报文段时延突然增大很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段，于是重传，造成死锁
>
> - 修正方法：**报文段每重传一次，就把超时重传时间 RTO 增大一些，典型的做法是将 RTO 的值取为旧 RTO 的 2 倍**

##### 例题

![image-20231112213856529](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213856529.png)

![image-20231112213903476](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213903476.png)

![image-20231112213908475](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213908475.png)

![image-20231112213915628](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213915628.png)

#### TCP 的选择确认

在之前介绍 TCP 的快重传和可靠传输时，TCP 接收方**只能对按序收到的数据中的最高序号给出确认**。当发送方**超时重传**时，接收方之前**已收到的未按序到达的数据也会被重传**。

> 能否设法只传送缺少的数据而不重传已经正确到达、只是未按序到达的数据呢？

TCP 可以使用选择确认 `（Selective ACK，SACK）`

![image-20231126163545024](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126163545024.png)

![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231126163605321.png)

​    SACK 相关文档并没有指明发送方应当怎样响应 SACK。因此大多数的 TCP 实现还是重传所有未被确认的数据块。



## UDP 和 TCP 的对比

### 无连接的 `UDP` 和面向连接的 `TCP`

> 连接指**逻辑连接关系**，而不是物理连接

![image-20231112213122300](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213122300.png)


### `UDP`和`TCP`对单播、多播和广播的支持情况

> `UDP`支持单播、多播和广播
>
> `TCP`仅支持单播

### `UDP`和`TCP`对应用层报文的处理

> `UDP`是**面向应用报文**的
>
> `TCP`是**面向字节流**的

### `UDP`和`TCP`对数据传输可靠性的支持情况

![image-20231112213144757](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213144757.png)

### `UDP`和`TCP`首部的对比

![](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/image-20231112213204520.png)

### 总结

> **UDP**
>
> - 无连接
> - 支持“一对一”、“一对多”、“多对一”和“多对多”交互通信
> - 面向应用报文
> - 尽最大努力交付，即不可靠；不使用流量控制和拥塞控制
> - 首部开销小，仅8字节
>
> **TCP**
>
> - 面向连接
> - 每一条TCP连接只能有两个端点EP，只能是一对一通信
> - 面向字节流
> - 可靠传输，使用流量控制和拥塞控制
> - 首部最小20字节，最大60字节


